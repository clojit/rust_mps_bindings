#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(non_snake_case)]
#![allow(unused_parens)]
#![allow(unused_variables)]
#![allow(dead_code)]

extern crate libc;

//use std::default::Default;

use std::io;
use std::os;
use std::ptr;
use std::mem;

use std::fmt;

/* automatically generated by rust-bindgen for mps */
pub type ptrdiff_t = ::libc::c_long;
pub type size_t = ::libc::c_ulong;
pub type wchar_t = ::libc::c_int;
/*pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;*/
pub type mps_word_t = ::libc::c_ulong;
pub enum Struct_mps_arena_s { }
pub type mps_arena_t = *mut Struct_mps_arena_s;
pub enum Struct_mps_arena_class_s { }
pub type mps_arena_class_t = *mut Struct_mps_arena_class_s;
pub enum Struct_mps_pool_s { }
pub type mps_pool_t = *mut Struct_mps_pool_s;
pub enum Struct_mps_chain_s { }
pub type mps_chain_t = *mut Struct_mps_chain_s;
pub enum Struct_mps_fmt_s { }
pub type mps_fmt_t = *mut Struct_mps_fmt_s;
pub enum Struct_mps_root_s { }
pub type mps_root_t = *mut Struct_mps_root_s;
pub enum Struct_mps_pool_class_s { }
pub type mps_pool_class_t = *mut Struct_mps_pool_class_s;
pub type mps_class_t = mps_pool_class_t;
pub enum Struct_mps_thr_s { }
pub type mps_thr_t = *mut Struct_mps_thr_s;
pub type mps_ap_t = *mut Struct_mps_ap_s;
pub type mps_ld_t = *mut Struct_mps_ld_s;
pub type mps_ss_t = *mut Struct_mps_ss_s;
pub enum Struct_mps_message_s { }
pub type mps_message_t = *mut Struct_mps_message_s;
pub enum Struct_mps_alloc_pattern_s { }
pub type mps_alloc_pattern_t = *mut Struct_mps_alloc_pattern_s;
pub enum Struct_mps_frame_s { }
pub type mps_frame_t = *mut Struct_mps_frame_s;
pub enum Struct_mps_key_s { }
pub type mps_key_t = *const Struct_mps_key_s;
pub type mps_bool_t = ::libc::c_int;
pub type mps_res_t = ::libc::c_int;
pub type mps_addr_t = *mut ::libc::c_void;
pub type mps_align_t = size_t;
pub type mps_rm_t = ::libc::c_uint;
pub type mps_rank_t = ::libc::c_uint;
pub type mps_message_type_t = ::libc::c_uint;
pub type mps_clock_t = mps_word_t;
pub type mps_label_t = mps_word_t;
pub type Enum_d1 = ::libc::c_uint;
pub const MPS_RES_OK: ::libc::c_int = 0;
pub const MPS_RES_FAIL: ::libc::c_int = 1;
pub const MPS_RES_RESOURCE: ::libc::c_int = 2;
pub const MPS_RES_MEMORY: ::libc::c_int = 3;
pub const MPS_RES_LIMIT: ::libc::c_int = 4;
pub const MPS_RES_UNIMPL: ::libc::c_int = 5;
pub const MPS_RES_IO: ::libc::c_int = 6;
pub const MPS_RES_COMMIT_LIMIT: ::libc::c_int = 7;
pub const MPS_RES_PARAM: ::libc::c_int = 8;
pub const _mps_MPS_RES_LIMIT: ::libc::c_int = 9;
pub type mps_root_scan_t =
    ::std::option::Option<extern "C" fn
                              (arg1: mps_ss_t, arg2: *mut ::libc::c_void,
                               arg3: size_t) -> mps_res_t>;
pub type mps_fmt_scan_t =
    ::std::option::Option<extern "C" fn
                              (arg1: mps_ss_t, arg2: mps_addr_t,
                               arg3: mps_addr_t) -> mps_res_t>;
pub type mps_reg_scan_t =
    ::std::option::Option<extern "C" fn
                              (arg1: mps_ss_t, arg2: mps_thr_t,
                               arg3: *mut ::libc::c_void, arg4: size_t)
                              -> mps_res_t>;
pub type mps_fmt_skip_t =
    ::std::option::Option<extern "C" fn(arg1: mps_addr_t) -> mps_addr_t>;
pub type mps_fmt_copy_t =
    ::std::option::Option<extern "C" fn(arg1: mps_addr_t, arg2: mps_addr_t)>;
pub type mps_fmt_fwd_t =
    ::std::option::Option<extern "C" fn(arg1: mps_addr_t, arg2: mps_addr_t)>;
pub type mps_fmt_isfwd_t =
    ::std::option::Option<extern "C" fn(arg1: mps_addr_t) -> mps_addr_t>;
pub type mps_fmt_pad_t =
    ::std::option::Option<extern "C" fn(arg1: mps_addr_t, arg2: size_t)>;
pub type mps_fmt_class_t =
    ::std::option::Option<extern "C" fn(arg1: mps_addr_t) -> mps_addr_t>;
pub type mps_fun_t = ::std::option::Option<extern "C" fn()>;
#[repr(C)]
pub struct Struct_mps_arg_s {
    pub key: mps_key_t,
    pub val: mps_args_val,
}
#[repr(C)]
pub struct mps_args_val {
    pub data: [u64, ..1u],
}
impl mps_args_val {
    pub fn b(&mut self) -> *mut mps_bool_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn c(&mut self) -> *mut ::libc::c_char {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn string(&mut self) -> *mut *const ::libc::c_char {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn i(&mut self) -> *mut ::libc::c_int {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn u(&mut self) -> *mut ::libc::c_uint {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn l(&mut self) -> *mut ::libc::c_long {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn ul(&mut self) -> *mut ::libc::c_ulong {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn f(&mut self) -> *mut ::libc::c_float {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn d(&mut self) -> *mut ::libc::c_double {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn size(&mut self) -> *mut size_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn fun(&mut self) -> *mut mps_fun_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn addr(&mut self) -> *mut mps_addr_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn format(&mut self) -> *mut mps_fmt_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn chain(&mut self) -> *mut mps_chain_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn pool_debug_options(&mut self) ->
     *mut *mut Struct_mps_pool_debug_option_s {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn addr_method(&mut self) ->
     *mut ::std::option::Option<extern "C" fn(arg1: mps_addr_t)
                                    -> mps_addr_t> {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn align(&mut self) -> *mut mps_align_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn count(&mut self) -> *mut mps_word_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn p(&mut self) -> *mut *mut ::libc::c_void {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn rank(&mut self) -> *mut mps_rank_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn fmt_scan(&mut self) -> *mut mps_fmt_scan_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn fmt_skip(&mut self) -> *mut mps_fmt_skip_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn fmt_fwd(&mut self) -> *mut mps_fmt_fwd_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn fmt_isfwd(&mut self) -> *mut mps_fmt_isfwd_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn fmt_pad(&mut self) -> *mut mps_fmt_pad_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn fmt_class(&mut self) -> *mut mps_fmt_class_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn pool(&mut self) -> *mut mps_pool_t {
        unsafe { ::std::mem::transmute(self) }
    }
}
pub type mps_arg_s = Struct_mps_arg_s;
pub type Enum_Unnamed3 = ::libc::c_uint;
pub const _mps_MESSAGE_TYPE_FINALIZATION: ::libc::c_uint = 0;
pub const _mps_MESSAGE_TYPE_GC: ::libc::c_uint = 1;
pub const _mps_MESSAGE_TYPE_GC_START: ::libc::c_uint = 2;
#[repr(C)]
pub struct Struct_mps_ap_s {
    pub init: mps_addr_t,
    pub alloc: mps_addr_t,
    pub limit: mps_addr_t,
    pub _frameptr: mps_addr_t,
    pub _enabled: mps_bool_t,
    pub _lwpoppending: mps_bool_t,
}
pub type mps_ap_s = Struct_mps_ap_s;
pub type mps_sac_t = *mut Struct__mps_sac_s;
#[repr(C)]
pub struct Struct__mps_sac_freelist_block_s {
    pub _size: size_t,
    pub _count: size_t,
    pub _count_max: size_t,
    pub _blocks: mps_addr_t,
}
pub type _mps_sac_freelist_block_s = Struct__mps_sac_freelist_block_s;
#[repr(C)]
pub struct Struct__mps_sac_s {
    pub _middle: size_t,
    pub _trapped: mps_bool_t,
    pub _freelists: [_mps_sac_freelist_block_s, ..16u],
}
pub type _mps_sac_s = Struct__mps_sac_s;
#[repr(C)]
pub struct Struct_mps_sac_class_s {
    pub mps_block_size: size_t,
    pub mps_cached_count: size_t,
    pub mps_frequency: ::libc::c_uint,
}
pub type mps_sac_class_s = Struct_mps_sac_class_s;
#[repr(C)]
pub struct Struct_mps_ld_s {
    pub _epoch: mps_word_t,
    pub _rs: mps_word_t,
}
pub type mps_ld_s = Struct_mps_ld_s;
#[repr(C)]
pub struct Struct_mps_ss_s {
    pub _zs: mps_word_t,
    pub _w: mps_word_t,
    pub _ufs: mps_word_t,
}
pub type mps_ss_s = Struct_mps_ss_s;
#[repr(C)]
pub struct Struct_mps_fmt_A_s {
    pub align: mps_align_t,
    pub scan: mps_fmt_scan_t,
    pub skip: mps_fmt_skip_t,
    pub copy: mps_fmt_copy_t,
    pub fwd: mps_fmt_fwd_t,
    pub isfwd: mps_fmt_isfwd_t,
    pub pad: mps_fmt_pad_t,
}
pub type mps_fmt_A_s = Struct_mps_fmt_A_s;
pub type mps_fmt_A_t = *mut Struct_mps_fmt_A_s;
#[repr(C)]
pub struct Struct_mps_fmt_B_s {
    pub align: mps_align_t,
    pub scan: mps_fmt_scan_t,
    pub skip: mps_fmt_skip_t,
    pub copy: mps_fmt_copy_t,
    pub fwd: mps_fmt_fwd_t,
    pub isfwd: mps_fmt_isfwd_t,
    pub pad: mps_fmt_pad_t,
    pub mps_class: mps_fmt_class_t,
}
pub type mps_fmt_B_s = Struct_mps_fmt_B_s;
pub type mps_fmt_B_t = *mut Struct_mps_fmt_B_s;
#[repr(C)]
pub struct Struct_mps_fmt_auto_header_s {
    pub align: mps_align_t,
    pub scan: mps_fmt_scan_t,
    pub skip: mps_fmt_skip_t,
    pub fwd: mps_fmt_fwd_t,
    pub isfwd: mps_fmt_isfwd_t,
    pub pad: mps_fmt_pad_t,
    pub mps_headerSize: size_t,
}
pub type mps_fmt_auto_header_s = Struct_mps_fmt_auto_header_s;
#[repr(C)]
pub struct Struct_mps_fmt_fixed_s {
    pub align: mps_align_t,
    pub scan: mps_fmt_scan_t,
    pub fwd: mps_fmt_fwd_t,
    pub isfwd: mps_fmt_isfwd_t,
    pub pad: mps_fmt_pad_t,
}
pub type mps_fmt_fixed_s = Struct_mps_fmt_fixed_s;
#[repr(C)]
pub struct Struct_mps_gen_param_s {
    pub mps_capacity: size_t,
    pub mps_mortality: ::libc::c_double,
}
pub type mps_gen_param_s = Struct_mps_gen_param_s;
pub type mps_tramp_t =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut ::libc::c_void, arg2: size_t)
                              -> *mut ::libc::c_void>;

pub type mps_formatted_objects_stepper_t =
    ::std::option::Option<extern "C" fn
                              (arg1: mps_addr_t, arg2: mps_fmt_t,
                               arg3: mps_pool_t, arg4: *mut ::libc::c_void,
                               arg5: size_t)>;

pub type mps_roots_stepper_t =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut mps_addr_t, arg2: mps_root_t,
                               arg3: *mut ::libc::c_void, arg4: size_t)>;

// mpscamc.h
// typedef void (*mps_amc_apply_stepper_t)(mps_addr_t, void *, size_t);
pub type mps_amc_apply_stepper_t =
    ::std::option::Option<extern "C" fn
                              (arg1: mps_addr_t, 
                               arg2: *mut ::libc::c_void,
                               arg3: size_t)>;


#[repr(C)]
pub struct Struct_mps_pool_debug_option_s {
    pub fence_template: *const ::libc::c_void,
    pub fence_size: size_t,
    pub free_template: *const ::libc::c_void,
    pub free_size: size_t,
}
pub type mps_pool_debug_option_s = Struct_mps_pool_debug_option_s;

#[link(name = "mps", kind="static")]
extern "C" {
    pub static _mps_key_ARGS_END: Struct_mps_key_s;

    pub static mut mps_args_none: *mut mps_arg_s;

    pub static _mps_key_ARENA_SIZE: Struct_mps_key_s;

    pub static _mps_key_ARENA_GRAIN_SIZE: Struct_mps_key_s;
    pub static _mps_key_ARENA_ZONED: Struct_mps_key_s;
    pub static _mps_key_FORMAT: Struct_mps_key_s;
    pub static _mps_key_CHAIN: Struct_mps_key_s;
    pub static _mps_key_GEN: Struct_mps_key_s;
    pub static _mps_key_RANK: Struct_mps_key_s;
    pub static _mps_key_EXTEND_BY: Struct_mps_key_s;
    pub static _mps_key_LARGE_SIZE: Struct_mps_key_s;
    pub static _mps_key_MIN_SIZE: Struct_mps_key_s;
    pub static _mps_key_MEAN_SIZE: Struct_mps_key_s;
    pub static _mps_key_MAX_SIZE: Struct_mps_key_s;
    pub static _mps_key_ALIGN: Struct_mps_key_s;
    pub static _mps_key_SPARE: Struct_mps_key_s;
    pub static _mps_key_INTERIOR: Struct_mps_key_s;
    pub static _mps_key_VMW3_TOP_DOWN: Struct_mps_key_s;
    pub static _mps_key_FMT_ALIGN: Struct_mps_key_s;
    pub static _mps_key_FMT_HEADER_SIZE: Struct_mps_key_s;
    pub static _mps_key_FMT_SCAN: Struct_mps_key_s;
    pub static _mps_key_FMT_SKIP: Struct_mps_key_s;
    pub static _mps_key_FMT_FWD: Struct_mps_key_s;
    pub static _mps_key_FMT_ISFWD: Struct_mps_key_s;
    pub static _mps_key_FMT_PAD: Struct_mps_key_s;
    pub static _mps_key_FMT_CLASS: Struct_mps_key_s;
    pub static _mps_key_POOL_DEBUG_OPTIONS: Struct_mps_key_s;
    pub fn _mps_args_set_key(args: [mps_arg_s, ..32u], i: ::libc::c_uint,
                             key: mps_key_t);
    pub fn mps_rank_ambig() -> mps_rank_t;
    pub fn mps_rank_exact() -> mps_rank_t;
    pub fn mps_rank_weak() -> mps_rank_t;
    pub fn mps_arena_clamp(arg1: mps_arena_t);
    pub fn mps_arena_release(arg1: mps_arena_t);
    pub fn mps_arena_park(arg1: mps_arena_t);
    pub fn mps_arena_expose(arg1: mps_arena_t);
    pub fn mps_arena_unsafe_expose_remember_protection(arg1: mps_arena_t);
    pub fn mps_arena_unsafe_restore_protection(arg1: mps_arena_t);
    pub fn mps_arena_start_collect(arg1: mps_arena_t) -> mps_res_t;
    pub fn mps_arena_collect(arg1: mps_arena_t) -> mps_res_t;
    pub fn mps_arena_step(arg1: mps_arena_t, arg2: ::libc::c_double,
                          arg3: ::libc::c_double) -> mps_bool_t;
    pub fn mps_arena_create(arg1: *mut mps_arena_t,
                            arg2: mps_arena_class_t, ...) -> mps_res_t;

    /*pub fn mps_arena_create_v(arg1: *mut mps_arena_t, arg2: mps_arena_class_t,
                              arg3: va_list) -> mps_res_t;*/

    pub fn mps_arena_create_k(arg1: *mut mps_arena_t, arg2: mps_arena_class_t,
                              arg3: *mut mps_arg_s) -> mps_res_t;
    pub fn mps_arena_destroy(arg1: mps_arena_t);
    pub fn mps_arena_reserved(arg1: mps_arena_t) -> size_t;
    pub fn mps_arena_committed(arg1: mps_arena_t) -> size_t;
    pub fn mps_arena_spare_committed(arg1: mps_arena_t) -> size_t;
    pub fn mps_arena_commit_limit(arg1: mps_arena_t) -> size_t;
    pub fn mps_arena_commit_limit_set(arg1: mps_arena_t, arg2: size_t) ->
     mps_res_t;
    pub fn mps_arena_spare_commit_limit_set(arg1: mps_arena_t, arg2: size_t);
    pub fn mps_arena_spare_commit_limit(arg1: mps_arena_t) -> size_t;
    pub fn mps_arena_has_addr(arg1: mps_arena_t, arg2: mps_addr_t) ->
     mps_bool_t;
    pub fn mps_addr_pool(arg1: *mut mps_pool_t, arg2: mps_arena_t,
                         arg3: mps_addr_t) -> mps_bool_t;
    pub fn mps_addr_fmt(arg1: *mut mps_fmt_t, arg2: mps_arena_t,
                        arg3: mps_addr_t) -> mps_bool_t;
    pub fn mps_arena_extend(arg1: mps_arena_t, arg2: mps_addr_t, arg3: size_t)
     -> mps_res_t;
    pub fn mps_fmt_create_k(arg1: *mut mps_fmt_t, arg2: mps_arena_t,
                            arg3: *mut mps_arg_s) -> mps_res_t;
    pub fn mps_fmt_create_A(arg1: *mut mps_fmt_t, arg2: mps_arena_t,
                            arg3: *mut mps_fmt_A_s) -> mps_res_t;
    pub fn mps_fmt_create_B(arg1: *mut mps_fmt_t, arg2: mps_arena_t,
                            arg3: *mut mps_fmt_B_s) -> mps_res_t;
    pub fn mps_fmt_create_auto_header(arg1: *mut mps_fmt_t, arg2: mps_arena_t,
                                      arg3: *mut mps_fmt_auto_header_s) ->
     mps_res_t;
    pub fn mps_fmt_create_fixed(arg1: *mut mps_fmt_t, arg2: mps_arena_t,
                                arg3: *mut mps_fmt_fixed_s) -> mps_res_t;
    pub fn mps_fmt_destroy(arg1: mps_fmt_t);
    pub fn mps_pool_create(arg1: *mut mps_pool_t, arg2: mps_arena_t,
                           arg3: mps_pool_class_t, ...) -> mps_res_t;
    /*pub fn mps_pool_create_v(arg1: *mut mps_pool_t, arg2: mps_arena_t,
                             arg3: mps_pool_class_t, arg4: va_list) ->
     mps_res_t;*/
    pub fn mps_pool_create_k(arg1: *mut mps_pool_t, arg2: mps_arena_t,
                             arg3: mps_pool_class_t, arg4: *mut mps_arg_s) ->
     mps_res_t;
    pub fn mps_pool_destroy(arg1: mps_pool_t);
    pub fn mps_pool_total_size(arg1: mps_pool_t) -> size_t;
    pub fn mps_pool_free_size(arg1: mps_pool_t) -> size_t;
    pub fn mps_chain_create(arg1: *mut mps_chain_t, arg2: mps_arena_t,
                            arg3: size_t, arg4: *mut mps_gen_param_s) ->
     mps_res_t;
    pub fn mps_chain_destroy(arg1: mps_chain_t);
    pub fn mps_alloc(arg1: *mut mps_addr_t, arg2: mps_pool_t, arg3: size_t) ->
     mps_res_t;

    /*pub fn mps_alloc_v(arg1: *mut mps_addr_t, arg2: mps_pool_t, arg3: size_t,
                       arg4: va_list) -> mps_res_t;*/

    pub fn mps_free(arg1: mps_pool_t, arg2: mps_addr_t, arg3: size_t);
    pub fn mps_ap_create(arg1: *mut mps_ap_t, arg2: mps_pool_t, ...) ->
     mps_res_t;

    /*pub fn mps_ap_create_v(arg1: *mut mps_ap_t, arg2: mps_pool_t,
                           arg3: va_list) -> mps_res_t;*/

    pub fn mps_ap_create_k(arg1: *mut mps_ap_t, arg2: mps_pool_t,
                           arg3: *mut mps_arg_s) -> mps_res_t;
    pub fn mps_ap_destroy(arg1: mps_ap_t);
    pub fn mps_reserve(arg1: *mut mps_addr_t, arg2: mps_ap_t, arg3: size_t) ->
     mps_res_t;
    pub fn mps_commit(arg1: mps_ap_t, arg2: mps_addr_t, arg3: size_t) ->
     mps_bool_t;
    pub fn mps_ap_fill(arg1: *mut mps_addr_t, arg2: mps_ap_t, arg3: size_t) ->
     mps_res_t;
    pub fn mps_ap_fill_with_reservoir_permit(arg1: *mut mps_addr_t,
                                             arg2: mps_ap_t, arg3: size_t) ->
     mps_res_t;
    pub fn mps_ap_frame_push(arg1: *mut mps_frame_t, arg2: mps_ap_t) ->
     mps_res_t;
    pub fn mps_ap_frame_pop(arg1: mps_ap_t, arg2: mps_frame_t) -> mps_res_t;
    pub fn mps_ap_trip(arg1: mps_ap_t, arg2: mps_addr_t, arg3: size_t) ->
     mps_bool_t;
    pub fn mps_alloc_pattern_ramp() -> mps_alloc_pattern_t;
    pub fn mps_alloc_pattern_ramp_collect_all() -> mps_alloc_pattern_t;
    pub fn mps_ap_alloc_pattern_begin(arg1: mps_ap_t,
                                      arg2: mps_alloc_pattern_t) -> mps_res_t;
    pub fn mps_ap_alloc_pattern_end(arg1: mps_ap_t, arg2: mps_alloc_pattern_t)
     -> mps_res_t;
    pub fn mps_ap_alloc_pattern_reset(arg1: mps_ap_t) -> mps_res_t;
    pub fn mps_sac_create(arg1: *mut mps_sac_t, arg2: mps_pool_t,
                          arg3: size_t, arg4: *mut mps_sac_class_s) ->
     mps_res_t;
    pub fn mps_sac_destroy(arg1: mps_sac_t);
    pub fn mps_sac_alloc(arg1: *mut mps_addr_t, arg2: mps_sac_t, arg3: size_t,
                         arg4: mps_bool_t) -> mps_res_t;
    pub fn mps_sac_free(arg1: mps_sac_t, arg2: mps_addr_t, arg3: size_t);
    pub fn mps_sac_flush(arg1: mps_sac_t);
    pub fn mps_sac_fill(arg1: *mut mps_addr_t, arg2: mps_sac_t, arg3: size_t,
                        arg4: mps_bool_t) -> mps_res_t;
    pub fn mps_sac_empty(arg1: mps_sac_t, arg2: mps_addr_t, arg3: size_t);
    pub fn mps_reservoir_limit_set(arg1: mps_arena_t, arg2: size_t);
    pub fn mps_reservoir_limit(arg1: mps_arena_t) -> size_t;
    pub fn mps_reservoir_available(arg1: mps_arena_t) -> size_t;
    pub fn mps_reserve_with_reservoir_permit(arg1: *mut mps_addr_t,
                                             arg2: mps_ap_t, arg3: size_t) ->
     mps_res_t;
    pub fn mps_root_create(arg1: *mut mps_root_t, arg2: mps_arena_t,
                           arg3: mps_rank_t, arg4: mps_rm_t,
                           arg5: mps_root_scan_t, arg6: *mut ::libc::c_void,
                           arg7: size_t) -> mps_res_t;
    pub fn mps_root_create_table(arg1: *mut mps_root_t, arg2: mps_arena_t,
                                 arg3: mps_rank_t, arg4: mps_rm_t,
                                 arg5: *mut mps_addr_t, arg6: size_t) ->
     mps_res_t;
    pub fn mps_root_create_table_masked(arg1: *mut mps_root_t,
                                        arg2: mps_arena_t, arg3: mps_rank_t,
                                        arg4: mps_rm_t, arg5: *mut mps_addr_t,
                                        arg6: size_t, arg7: mps_word_t) ->
     mps_res_t;
    pub fn mps_root_create_fmt(arg1: *mut mps_root_t, arg2: mps_arena_t,
                               arg3: mps_rank_t, arg4: mps_rm_t,
                               arg5: mps_fmt_scan_t, arg6: mps_addr_t,
                               arg7: mps_addr_t) -> mps_res_t;
    pub fn mps_root_create_reg(arg1: *mut mps_root_t, arg2: mps_arena_t,
                               arg3: mps_rank_t, arg4: mps_rm_t,
                               arg5: mps_thr_t, arg6: mps_reg_scan_t,
                               arg7: *mut ::libc::c_void, arg8: size_t) ->
     mps_res_t;
    pub fn mps_root_destroy(arg1: mps_root_t);
    pub fn mps_stack_scan_ambig(arg1: mps_ss_t, arg2: mps_thr_t,
                                arg3: *mut ::libc::c_void, arg4: size_t) ->
     mps_res_t;
    pub fn mps_tramp(arg1: *mut *mut ::libc::c_void, arg2: mps_tramp_t,
                     arg3: *mut ::libc::c_void, arg4: size_t);
    pub fn mps_thread_reg(arg1: *mut mps_thr_t, arg2: mps_arena_t) ->
     mps_res_t;
    pub fn mps_thread_dereg(arg1: mps_thr_t);
    pub fn mps_ld_reset(arg1: mps_ld_t, arg2: mps_arena_t);
    pub fn mps_ld_add(arg1: mps_ld_t, arg2: mps_arena_t, arg3: mps_addr_t);
    pub fn mps_ld_merge(arg1: mps_ld_t, arg2: mps_arena_t, arg3: mps_ld_t);
    pub fn mps_ld_isstale(arg1: mps_ld_t, arg2: mps_arena_t, arg3: mps_addr_t)
     -> mps_bool_t;
    pub fn mps_ld_isstale_any(arg1: mps_ld_t, arg2: mps_arena_t) ->
     mps_bool_t;
    pub fn mps_collections(arg1: mps_arena_t) -> mps_word_t;
    pub fn mps_message_type_enable(arg1: mps_arena_t,
                                   arg2: mps_message_type_t);
    pub fn mps_message_type_disable(arg1: mps_arena_t,
                                    arg2: mps_message_type_t);
    pub fn mps_message_poll(arg1: mps_arena_t) -> mps_bool_t;
    pub fn mps_message_queue_type(arg1: *mut mps_message_type_t,
                                  arg2: mps_arena_t) -> mps_bool_t;
    pub fn mps_message_get(arg1: *mut mps_message_t, arg2: mps_arena_t,
                           arg3: mps_message_type_t) -> mps_bool_t;
    pub fn mps_message_discard(arg1: mps_arena_t, arg2: mps_message_t);
    pub fn mps_message_type(arg1: mps_arena_t, arg2: mps_message_t) ->
     mps_message_type_t;
    pub fn mps_message_clock(arg1: mps_arena_t, arg2: mps_message_t) ->
     mps_clock_t;
    pub fn mps_message_finalization_ref(arg1: *mut mps_addr_t,
                                        arg2: mps_arena_t,
                                        arg3: mps_message_t);
    pub fn mps_message_gc_live_size(arg1: mps_arena_t, arg2: mps_message_t) -> size_t;
    pub fn mps_message_gc_condemned_size(arg1: mps_arena_t,
                                         arg2: mps_message_t) -> size_t;
    pub fn mps_message_gc_not_condemned_size(arg1: mps_arena_t,
                                             arg2: mps_message_t) -> size_t;
    pub fn mps_message_gc_start_why(arg1: mps_arena_t, arg2: mps_message_t) -> *const ::libc::c_char;
    pub fn mps_finalize(arg1: mps_arena_t, arg2: *mut mps_addr_t) -> mps_res_t;
    pub fn mps_definalize(arg1: mps_arena_t, arg2: *mut mps_addr_t) -> mps_res_t;
    pub fn mps_telemetry_control(arg1: mps_word_t, arg2: mps_word_t) -> mps_word_t;
    pub fn mps_telemetry_set(arg1: mps_word_t);
    pub fn mps_telemetry_reset(arg1: mps_word_t);
    pub fn mps_telemetry_get() -> mps_word_t;
    pub fn mps_telemetry_intern(arg1: *const ::libc::c_char) -> mps_label_t;
    pub fn mps_telemetry_label(arg1: mps_addr_t, arg2: mps_label_t);
    pub fn mps_telemetry_flush();
    pub fn mps_arena_formatted_objects_walk(arg1: mps_arena_t,
                                            arg2:
                                                mps_formatted_objects_stepper_t,
                                            arg3: *mut ::libc::c_void,
                                            arg4: size_t);
    pub fn mps_arena_roots_walk(arg1: mps_arena_t, arg2: mps_roots_stepper_t,
                                arg3: *mut ::libc::c_void, arg4: size_t);
    pub fn mps_pool_check_fenceposts(arg1: mps_pool_t);
    pub fn mps_pool_check_free_space(arg1: mps_pool_t);
    pub fn mps_fix(arg1: mps_ss_t, arg2: *mut mps_addr_t) -> mps_res_t;
    pub fn _mps_fix2(arg1: mps_ss_t, arg2: *mut mps_addr_t) -> mps_res_t;


    //#include "mpsavm.h"
    pub fn mps_arena_class_vm() -> mps_arena_class_t;

    //#include "mpsacl.h"
    pub fn mps_arena_class_cl() -> mps_arena_class_t;


    //#include "mpscmvff.h"

    //#define mps_mvff_free_size         mps_pool_free_size
    //#define mps_mvff_size              mps_pool_total_size
    pub fn mps_class_mvff() -> mps_pool_class_t;
    pub fn mps_class_mvff_debug() -> mps_pool_class_t;

    pub static _mps_key_MVFF_SLOT_HIGH : Struct_mps_key_s;
    pub static _mps_key_MVFF_ARENA_HIGH : Struct_mps_key_s;
    pub static _mps_key_MVFF_FIRST_FIT : Struct_mps_key_s;

    // mpscamc.h
    pub fn mps_class_amc()  -> mps_pool_class_t;
    pub fn mps_class_amcz() -> mps_pool_class_t;

    pub fn mps_amc_apply(arg1 : mps_pool_t, arg2 : mps_amc_apply_stepper_t, arg3 :  *mut ::libc::c_void, arg4 : size_t) -> ::libc::c_void;

}

// mps.h
static MPS_KEY_ARGS_END : mps_key_t  = (&_mps_key_ARGS_END);
static MPS_KEY_ARENA_SIZE : mps_key_t = (&_mps_key_ARENA_SIZE);
static MPS_KEY_ARENA_GRAIN_SIZE : mps_key_t = (&_mps_key_ARENA_GRAIN_SIZE);
static MPS_KEY_ARENA_ZONED : mps_key_t = (&_mps_key_ARENA_ZONED);
static MPS_KEY_FORMAT : mps_key_t = (&_mps_key_FORMAT);
static MPS_KEY_CHAIN : mps_key_t = (&_mps_key_CHAIN);
static MPS_KEY_GEN : mps_key_t = (&_mps_key_GEN);
static MPS_KEY_RANK : mps_key_t = (&_mps_key_RANK);
static MPS_KEY_EXTEND_BY : mps_key_t = (&_mps_key_EXTEND_BY);
static MPS_KEY_LARGE_SIZE : mps_key_t = (&_mps_key_LARGE_SIZE);
static MPS_KEY_MIN_SIZE : mps_key_t = (&_mps_key_MIN_SIZE);
static MPS_KEY_MEAN_SIZE : mps_key_t = (&_mps_key_MEAN_SIZE);
static MPS_KEY_MAX_SIZE : mps_key_t = (&_mps_key_MAX_SIZE);
static MPS_KEY_ALIGN : mps_key_t = (&_mps_key_ALIGN);
static MPS_KEY_SPARE : mps_key_t = (&_mps_key_SPARE);
static MPS_KEY_INTERIOR : mps_key_t = (&_mps_key_INTERIOR);
static MPS_KEY_VMW3_TOP_DOWN : mps_key_t = (&_mps_key_VMW3_TOP_DOWN);
static MPS_KEY_FMT_ALIGN : mps_key_t = (&_mps_key_FMT_ALIGN);
static MPS_KEY_FMT_HEADER_SIZE : mps_key_t = (&_mps_key_FMT_HEADER_SIZE);
static MPS_KEY_FMT_SCAN : mps_key_t = (&_mps_key_FMT_SCAN);
static MPS_KEY_FMT_SKIP : mps_key_t = (&_mps_key_FMT_SKIP);
static MPS_KEY_FMT_FWD : mps_key_t = (&_mps_key_FMT_FWD);
static MPS_KEY_FMT_ISFWD : mps_key_t = (&_mps_key_FMT_ISFWD);
static MPS_KEY_FMT_PAD : mps_key_t = (&_mps_key_FMT_PAD);
static MPS_KEY_FMT_CLASS : mps_key_t = (&_mps_key_FMT_CLASS);

//mpscmvff.h
static MPS_KEY_MVFF_SLOT_HIGH : mps_key_t = (&_mps_key_MVFF_SLOT_HIGH);
static MPS_KEY_MVFF_ARENA_HIGH : mps_key_t = (&_mps_key_MVFF_ARENA_HIGH);
static MPS_KEY_MVFF_FIRST_FIT : mps_key_t = (&_mps_key_MVFF_FIRST_FIT);


// --------------- SAFE Interface ---------------

// #include "mps.h" SAFE
pub fn safe_mps_arena_create_k(arena: *mut mps_arena_t, arena_class : mps_arena_class_t, kvargs : &mut [mps_arg_s] ) -> mps_res_t {
    return unsafe { mps_arena_create_k(arena, arena_class , kvargs.as_mut_ptr() ) };
}

pub fn safe_mps_pool_create_k(pool : *mut mps_pool_t, arena : mps_arena_t, pool_class : mps_pool_class_t, kvargs : &mut [mps_arg_s] ) -> mps_res_t {
      return unsafe { mps_pool_create_k( pool, arena, pool_class, kvargs.as_mut_ptr() ) };
}

pub fn safe_mps_ap_create_k(ap : *mut mps_ap_t, pool : mps_pool_t, kvargs : &mut [mps_arg_s]) -> mps_res_t {
    return unsafe { mps_ap_create_k(ap, pool, kvargs.as_mut_ptr() ) };
}

pub fn safe_mps_reserve(addr : *mut mps_addr_t, allocation_point : mps_ap_t, size: size_t) ->  mps_res_t {
    return unsafe { mps_reserve(addr, allocation_point, size) };
}

pub fn safe_mps_commit(allocation_point : mps_ap_t, addr : mps_addr_t, size :  size_t) -> bool {

    let int_bool : i32 = unsafe { mps_commit(allocation_point, addr, size) };

    if int_bool == 0 {
        return false;
    } else {
        return true;
    }
}

pub fn safe_mps_rank_ambig() -> mps_rank_t {
    return unsafe { mps_rank_ambig() };
}
pub fn safe_mps_rank_exact() -> mps_rank_t {
    return unsafe { mps_rank_exact() };
}
pub fn safe_mps_rank_weak() -> mps_rank_t {
    return unsafe { mps_rank_weak() };
}

pub fn safe_mps_root_create(root : *mut mps_root_t, 
                            arena : mps_arena_t,
                            rank : mps_rank_t,
                            root_mode : mps_rm_t,
                            root_scan : mps_root_scan_t,
                            param_p :  *mut ::libc::c_void,
                            size : size_t) ->  mps_res_t {

    return unsafe { mps_root_create(root, arena, rank, root_mode, root_scan, param_p, size) };
}

//#include "mpsavm.h" SAFE
pub fn safe_mps_arena_class_vm() -> mps_arena_class_t {
    return unsafe { mps_arena_class_vm() };
}

//#include "mpsacl.h" SAFE
pub fn safe_mps_arena_class_cl() -> mps_arena_class_t {
    return unsafe { mps_arena_class_cl() };
}

//#include "mpscmvff.h" SAFE
pub fn safe_mps_class_mvff() -> mps_pool_class_t {
    return unsafe { mps_class_mvff()  };
}

pub fn safe_mps_class_mvff_debug() -> mps_pool_class_t {
    return unsafe { mps_class_mvff_debug()  };
}

//#include "mpscamc.h" SAFE

pub fn safe_class_amc() -> mps_pool_class_t {
    return unsafe {  mps_class_amc()  };
}

pub fn safe_class_amcz() -> mps_pool_class_t {
    return unsafe {  mps_class_amcz()  };
}


/////////////////////// Simple Types for AMC example with Scan ////////////////////


#[deriving(Show)]
#[repr(C)]
pub enum ObjU {
      Int(i64),
      Pair(ObjT, ObjT)
}

pub type ObjT = *mut ObjU;

pub fn make_integer (i : i64, ap : mps_ap_t) -> ObjT {
    let mut obj : ObjT = unsafe { mem::zeroed() };
    let mut addr : mps_addr_t = unsafe{ mem::zeroed() };

    let size : size_t = mem::size_of::<ObjU>() as u64;
    
    loop {
        let res = safe_mps_reserve(&mut addr, ap, size);
        unsafe {
            obj =  mem::transmute(addr);
            ptr::write(obj, Int(i));         
        }
        if (MPS_RES_OK != res) {
            panic!("could not reserve int space");
        } 
        if safe_mps_commit(ap, addr, size) {
            break;
        }
    }
    return obj;
}

pub fn make_pair (car : ObjT, cdr : ObjT, ap : mps_ap_t) -> ObjT {

    let mut obj : ObjT = unsafe { mem::zeroed() };
    let mut addr : mps_addr_t = unsafe{ mem::zeroed() };

    let size : size_t = mem::size_of::<ObjU>() as u64;
    
    loop {
        let res = safe_mps_reserve(&mut addr, ap, size);
        
        unsafe {
            obj =  mem::transmute(addr);
            ptr::write(obj, Pair(car, cdr));         
        }

        if (MPS_RES_OK != res) {
            panic!("could not reserve pair space");
        } 

        if safe_mps_commit(ap, addr, size) {
            break;
        }
    }
    return obj;
}

pub fn print ( obj_ref : ObjT ) {
    match unsafe { *obj_ref } {
        Int(i) => print!("{}", i),
        Pair(x, y) => { print!( "Pair(" );
                        print(x);
                        print!( ", " ); 
                        print(y);
                        print!( ")" );
                      }
    }
}
pub fn println ( obj_ref : ObjT ) {
    print(obj_ref);
    print!("\n");
}


/*
typedef struct fwd2_s {
    type_t type; // TYPE_FWD2
    obj_t fwd; // forwarded object
} fwd2_s;

typedef struct fwd_s {
    type_t type; // TYPE_FWD 
    obj_t fwd; // forwarded object 
    size_t size; // total size of this object 
} fwd_s;

typedef struct pad1_s {
    type_t type; // TYPE_PAD1 
} pad1_s;

typedef struct pad_s {
    type_t type; // TYPE_PAD
    size_t size; // total size of this object
} pad_s;

*/
/*
#[repr(C)]
pub struct Struct_mps_ss_s {
    pub _zs: mps_word_t,
    pub _w: mps_word_t,
    pub _ufs: mps_word_t,
}*/


extern fn obj_scan(ss : mps_ss_t, start_base : mps_addr_t, limit : mps_addr_t) -> mps_res_t {


    // -------------- MPS_SCAN_BEGIN ----------------
    /*
    #define MPS_SCAN_BEGIN(ss) \
      MPS_BEGIN \
        mps_ss_t _ss = (ss); \
        mps_word_t _mps_zs = (_ss)->_zs; \
        mps_word_t _mps_w = (_ss)->_w; \
        mps_word_t _mps_ufs = (_ss)->_ufs; \
        mps_word_t _mps_wt; \
        {
    */

    unsafe {
        let mut _mps_zs : mps_word_t  =   (*ss)._zs;
        let mut _mps_w : mps_word_t =  (*ss)._w;
        let mut _mps_ufs : mps_word_t = (*ss)._ufs;

        let mut _mps_wt : mps_word_t =  mem::zeroed();
        // ------------------------------------------------

        let mut base = start_base.clone();

        while (base < limit) {
            let obj : ObjT = mem::transmute(base) ;
            
            match (*obj) {
                Int(i) => { base = base.offset(1) }

                Pair(x, y) => { //  ----------- FIX 1 -----------
                                // let res : mps_res_t = MPS_FIX12(ss, &_addr);
                                // if (res != MPS_RES_OK) return res;

                                //  ----------- FIX 2 -----------
                                /* if ( MPS_FIX1(ss, *(ref_io))  ) {
                                      return MPS_FIX2(ss, ref_io)
                                   } else {
                                      return MPS_RES_OK
                                   }*/


                                //  ----------- FIX 3 -----------
                                /*
                                #define MPS_FIX1(ss, ref_) 

                                  (_mps_wt = (mps_word_t)1 << ( (mps_word_t)(ref_) >> _mps_zs 
                                                                & (sizeof(mps_word_t) * CHAR_BIT - 1)), 
                                   _mps_ufs |= _mps_wt, 
                                   (_mps_w & _mps_wt) != 0)
                                */

                                 // printf("a << n: %d\n", a << b); 
                                
                                _mps_wt =  1  <<  (x as mps_word_t >> _mps_zs as uint 
                                                   & mem::size_of::<mps_word_t>() as u64 * 8 - 1 ) as uint;
                                 
                                 _mps_ufs = _mps_ufs | _mps_wt;

                                let res : mps_res_t =  if ( (_mps_w & _mps_wt) != 0 ) {  

                                                             _mps_fix2(ss, mem::transmute(x) )

                                                        } else { 
                                                            MPS_RES_OK
                                                        };

                                if (res != MPS_RES_OK) { 
                                    return res;
                                };

                                base =  base.offset(1);
                              }
            }
        }
        (*ss)._ufs = _mps_ufs;
        return MPS_RES_OK;
    }

}
/*
static mps_res_t obj_scan(mps_ss_t ss, mps_addr_t base, mps_addr_t limit)
{
    MPS_SCAN_BEGIN(ss) {
        while (base < limit) {
            obj_t obj = base;
            switch (TYPE(obj)) {
            case TYPE_PAIR:
                FIX(CAR(obj));
                FIX(CDR(obj));
                base = (char *)base + ALIGN_OBJ(sizeof(pair_s));
                break;
            case TYPE_INTEGER:
                base = (char *)base + ALIGN_OBJ(sizeof(integer_s));
                break;
            // ... and so on for the other types ... *
            default:
                assert(0);
                fprintf(stderr, "Unexpected object on the heap\n");
                abort();
            }
        }
    } MPS_SCAN_END(ss);
    return MPS_RES_OK;
}*/


/*extern fn obj_skip(base : mps_addr_t) -> mps_addr_t {

    let obj : mps_addr_t = base;
    let new_base : mps_addr_t = (obj as u64 + 8 * 8 as u64) as mps_addr_t;
    
    return new_base;
}*/




fn main() {
    let mut res : mps_res_t = unsafe{ mem::zeroed() };
    let mut arena : mps_arena_t = unsafe{ mem::zeroed() };
    let mut globals_root : mps_root_t = unsafe{ mem::zeroed() };

    // ------------------------ Arena ------------------------
    let mut arena_args : [mps_arg_s, ..2] = unsafe{ mem::zeroed() };

    arena_args[0] = Struct_mps_arg_s { key: MPS_KEY_ARENA_SIZE,
                                       val:  mps_args_val { data: [32 * 1024 * 1024] }
                                     };

    arena_args[1] = Struct_mps_arg_s { key: MPS_KEY_ARGS_END,
                                       val:  mps_args_val { data: [0] }
                                     };

    res = safe_mps_arena_create_k(&mut arena, safe_mps_arena_class_vm(), arena_args);

    if (MPS_RES_OK != res) {
        println!("Clould not creat arena");
    } else {
        println!("Arena created");
    }

    //println!("ObjU: {}", mem::size_of::<ObjU>());
    //println!("ObjT: {}", mem::size_of::<ObjT>());
    //println!("i64:  {}", mem::size_of::<i64>());

    // ------------------------MVFF Pool (Manual Pool) ------------------------
    println!("---------------- Example Code MVFF Pool --------------------");

    let mut mvff_pool : mps_pool_t = unsafe{ mem::zeroed() };

    const mvff_args_size : uint = 1;
    let mut mvff_args : [mps_arg_s, ..mvff_args_size] = unsafe{ mem::zeroed() };
    
    mvff_args[mvff_args_size-1] = Struct_mps_arg_s { key: MPS_KEY_ARGS_END,
                                                     val: mps_args_val { data: [0] }
                                                   };
    
    res = safe_mps_pool_create_k(&mut mvff_pool, arena, safe_mps_class_mvff(), mvff_args );

    if (MPS_RES_OK != res) {
        println!("Clould not creat MVFF pool");
    } else {
        println!("MVFF Pool created");
    }
    
    // ------------------------ Allocation point MVFF ------------------------
    
    let mut mvff_alloc_point : mps_ap_t = unsafe{ mem::zeroed() };
    const ap_args_size : uint = 1;
    let mut ap_args : [mps_arg_s, ..ap_args_size] = unsafe{  mem::zeroed() };
    
    ap_args[ap_args_size-1] = Struct_mps_arg_s { key: MPS_KEY_ARGS_END,
                                                 val:  mps_args_val { data: [0] }
                                                };

    res = safe_mps_ap_create_k(&mut mvff_alloc_point, mvff_pool, ap_args);

    if (MPS_RES_OK != res) {
        println!("Clould not creat MVFF AP");
    } else {
        println!("MVFF AP created");
    }

    let i1 : ObjT = make_integer(7, mvff_alloc_point);
    let i2 : ObjT = make_integer(10, mvff_alloc_point);


    let p1 : ObjT = make_pair(i1, i2, mvff_alloc_point);

    let p2 = make_pair(p1, make_integer(9, mvff_alloc_point), mvff_alloc_point);

    println(p2);

    //println!("i: {}",  ptr::read(i) );
    
    

    // ---------------------------AMC---------------------------------------
    /*
    
    println!("\n---------------- Example Code AMC Pool --------------------");

    
    //MPS_ARGS_BEGIN(args) {
    //    MPS_ARGS_ADD(args, MPS_KEY_FMT_ALIGN, ALIGNMENT);
    //    MPS_ARGS_ADD(args, MPS_KEY_FMT_SCAN, obj_scan);
    //    MPS_ARGS_ADD(args, MPS_KEY_FMT_SKIP, obj_skip);
    //    MPS_ARGS_ADD(args, MPS_KEY_FMT_FWD, obj_fwd);
    //    MPS_ARGS_ADD(args, MPS_KEY_FMT_ISFWD, obj_isfwd);
    //    MPS_ARGS_ADD(args, MPS_KEY_FMT_PAD, obj_pad);
    //    res = mps_fmt_create_k(&obj_fmt, arena, args);
    //} MPS_ARGS_END(args);
    //if (res != MPS_RES_OK) error("Couldn't create obj format");
    
    const fmt_args_size : uint = 6;

    let mut obj_fmt : mps_fmt_t = unsafe { mem::zeroed() };

    let mut fmt_args : [mps_arg_s, ..fmt_args_size] = unsafe{ mem::zeroed() };

    fmt_args[0] = Struct_mps_arg_s { key: MPS_KEY_FMT_ALIGN,
                                     val: mps_args_val { data: [ std::mem::size_of::<mps_word_t>() as u64 ] }
                                   };
    
    fmt_args[1] = Struct_mps_arg_s { key: MPS_KEY_FMT_SKIP,
                                     val: mps_args_val { data: [ 0 // obj_skip as u64 
                                                               ] }
                                   };
    
    fmt_args[2] = Struct_mps_arg_s { key: MPS_KEY_FMT_FWD,
                                     val: mps_args_val { data: [ 0 // obj_fwd as u64 
                                                                ] }
                                   };
    
    fmt_args[3] = Struct_mps_arg_s { key: MPS_KEY_FMT_ISFWD,
                                     val: mps_args_val { data: [ 0 ] }
                                   };

    fmt_args[4] = Struct_mps_arg_s { key: MPS_KEY_FMT_PAD,
                                     val: mps_args_val { data: [ 0 ] }
                                   };

    fmt_args[5] = Struct_mps_arg_s { key: MPS_KEY_ARGS_END,
                                     val:  mps_args_val { data: [0] }
                                   };

    res = unsafe { mps_fmt_create_k(&mut obj_fmt, arena, fmt_args.as_mut_ptr()) };


    if (MPS_RES_OK != res) {
        println!("Couldn't object format created");
    } else {
        println!("object format created");
    }

    // ------------------------AMC Pool (Automatic Pool) ------------------------
   
    let mut amc_pool : mps_pool_t = unsafe{ mem::zeroed() };

    const amc_args_size : uint = 2;
    let mut amc_args : [mps_arg_s, ..amc_args_size] = unsafe{ mem::zeroed() };
    
    amc_args[0] = Struct_mps_arg_s { key: MPS_KEY_FORMAT,
                                     val: mps_args_val { data: [obj_fmt as u64] }
                                   };


    amc_args[amc_args_size-1] = Struct_mps_arg_s { key: MPS_KEY_ARGS_END,
                                                   val: mps_args_val { data: [0] }
                                 };
    

    res = safe_mps_pool_create_k(&mut amc_pool, arena, safe_mps_class_amcz(), amc_args );

    if (MPS_RES_OK != res) {
        println!("Clould not creat AMC pool");
    } else {
        println!("AMC Pool created");
    }

    // ------------------------ Allocation point AMC ------------------------

    let mut amc_alloc_point : mps_ap_t = unsafe{ mem::zeroed() };

    const ap_amc_args_size : uint = 1;
    let mut ap_amc_args : [mps_arg_s, ..ap_amc_args_size] = unsafe{ mem::zeroed() };
    
    ap_amc_args[ap_amc_args_size-1] = Struct_mps_arg_s { key: MPS_KEY_ARGS_END,
                                                         val: mps_args_val { data: [0] }
                                                       };

    res =  safe_mps_ap_create_k(&mut amc_alloc_point, amc_pool, ap_amc_args);

    if (MPS_RES_OK != res) {
        println!("Clould not creat AMC AP");
    } else {
        println!("AMC AP created");
    }
    */
}


extern fn obj_skip(base : mps_addr_t) -> mps_addr_t {

    let obj : mps_addr_t = base;
    let new_base : mps_addr_t = (obj as u64 + 8 * 8 as u64) as mps_addr_t;
    
    return new_base;
}
/*
extern fn obj_fwd(old : *mut mps_addr_t, new : *mut mps_addr_t) -> ::libc::c_void {
    old = new;
    let x : ::libc::c_void = unsafe{ mem::zeroed() };
    return x;
}
*/






