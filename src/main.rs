#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(non_snake_case)]
#![allow(unused_parens)]
#![allow(unused_variables)]
#![allow(dead_code)]

extern crate libc;

//use std::default::Default;

use std::io;
use std::os;

use std::mem;


/* automatically generated by rust-bindgen for mps */
pub type ptrdiff_t = ::libc::c_long;
pub type size_t = ::libc::c_ulong;
pub type wchar_t = ::libc::c_int;
/*pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;*/
pub type mps_word_t = ::libc::c_ulong;
pub enum Struct_mps_arena_s { }
pub type mps_arena_t = *mut Struct_mps_arena_s;
pub enum Struct_mps_arena_class_s { }
pub type mps_arena_class_t = *mut Struct_mps_arena_class_s;
pub enum Struct_mps_pool_s { }
pub type mps_pool_t = *mut Struct_mps_pool_s;
pub enum Struct_mps_chain_s { }
pub type mps_chain_t = *mut Struct_mps_chain_s;
pub enum Struct_mps_fmt_s { }
pub type mps_fmt_t = *mut Struct_mps_fmt_s;
pub enum Struct_mps_root_s { }
pub type mps_root_t = *mut Struct_mps_root_s;
pub enum Struct_mps_pool_class_s { }
pub type mps_pool_class_t = *mut Struct_mps_pool_class_s;
pub type mps_class_t = mps_pool_class_t;
pub enum Struct_mps_thr_s { }
pub type mps_thr_t = *mut Struct_mps_thr_s;
pub type mps_ap_t = *mut Struct_mps_ap_s;
pub type mps_ld_t = *mut Struct_mps_ld_s;
pub type mps_ss_t = *mut Struct_mps_ss_s;
pub enum Struct_mps_message_s { }
pub type mps_message_t = *mut Struct_mps_message_s;
pub enum Struct_mps_alloc_pattern_s { }
pub type mps_alloc_pattern_t = *mut Struct_mps_alloc_pattern_s;
pub enum Struct_mps_frame_s { }
pub type mps_frame_t = *mut Struct_mps_frame_s;
pub enum Struct_mps_key_s { }
pub type mps_key_t = *const Struct_mps_key_s;
pub type mps_bool_t = ::libc::c_int;
pub type mps_res_t = ::libc::c_int;
pub type mps_addr_t = *mut ::libc::c_void;
pub type mps_align_t = size_t;
pub type mps_rm_t = ::libc::c_uint;
pub type mps_rank_t = ::libc::c_uint;
pub type mps_message_type_t = ::libc::c_uint;
pub type mps_clock_t = mps_word_t;
pub type mps_label_t = mps_word_t;
pub type Enum_d1 = ::libc::c_uint;
pub const MPS_RES_OK: ::libc::c_int = 0;
pub const MPS_RES_FAIL: ::libc::c_int = 1;
pub const MPS_RES_RESOURCE: ::libc::c_int = 2;
pub const MPS_RES_MEMORY: ::libc::c_int = 3;
pub const MPS_RES_LIMIT: ::libc::c_int = 4;
pub const MPS_RES_UNIMPL: ::libc::c_int = 5;
pub const MPS_RES_IO: ::libc::c_int = 6;
pub const MPS_RES_COMMIT_LIMIT: ::libc::c_int = 7;
pub const MPS_RES_PARAM: ::libc::c_int = 8;
pub const _mps_MPS_RES_LIMIT: ::libc::c_int = 9;
pub type mps_root_scan_t =
    ::std::option::Option<extern "C" fn
                              (arg1: mps_ss_t, arg2: *mut ::libc::c_void,
                               arg3: size_t) -> mps_res_t>;
pub type mps_fmt_scan_t =
    ::std::option::Option<extern "C" fn
                              (arg1: mps_ss_t, arg2: mps_addr_t,
                               arg3: mps_addr_t) -> mps_res_t>;
pub type mps_reg_scan_t =
    ::std::option::Option<extern "C" fn
                              (arg1: mps_ss_t, arg2: mps_thr_t,
                               arg3: *mut ::libc::c_void, arg4: size_t)
                              -> mps_res_t>;
pub type mps_fmt_skip_t =
    ::std::option::Option<extern "C" fn(arg1: mps_addr_t) -> mps_addr_t>;
pub type mps_fmt_copy_t =
    ::std::option::Option<extern "C" fn(arg1: mps_addr_t, arg2: mps_addr_t)>;
pub type mps_fmt_fwd_t =
    ::std::option::Option<extern "C" fn(arg1: mps_addr_t, arg2: mps_addr_t)>;
pub type mps_fmt_isfwd_t =
    ::std::option::Option<extern "C" fn(arg1: mps_addr_t) -> mps_addr_t>;
pub type mps_fmt_pad_t =
    ::std::option::Option<extern "C" fn(arg1: mps_addr_t, arg2: size_t)>;
pub type mps_fmt_class_t =
    ::std::option::Option<extern "C" fn(arg1: mps_addr_t) -> mps_addr_t>;
pub type mps_fun_t = ::std::option::Option<extern "C" fn()>;
#[repr(C)]
pub struct Struct_mps_arg_s {
    pub key: mps_key_t,
    pub val: mps_args_val,
}
#[repr(C)]
pub struct mps_args_val {
    pub data: [u64, ..1u],
}
impl mps_args_val {
    pub fn b(&mut self) -> *mut mps_bool_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn c(&mut self) -> *mut ::libc::c_char {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn string(&mut self) -> *mut *const ::libc::c_char {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn i(&mut self) -> *mut ::libc::c_int {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn u(&mut self) -> *mut ::libc::c_uint {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn l(&mut self) -> *mut ::libc::c_long {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn ul(&mut self) -> *mut ::libc::c_ulong {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn f(&mut self) -> *mut ::libc::c_float {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn d(&mut self) -> *mut ::libc::c_double {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn size(&mut self) -> *mut size_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn fun(&mut self) -> *mut mps_fun_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn addr(&mut self) -> *mut mps_addr_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn format(&mut self) -> *mut mps_fmt_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn chain(&mut self) -> *mut mps_chain_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn pool_debug_options(&mut self) ->
     *mut *mut Struct_mps_pool_debug_option_s {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn addr_method(&mut self) ->
     *mut ::std::option::Option<extern "C" fn(arg1: mps_addr_t)
                                    -> mps_addr_t> {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn align(&mut self) -> *mut mps_align_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn count(&mut self) -> *mut mps_word_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn p(&mut self) -> *mut *mut ::libc::c_void {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn rank(&mut self) -> *mut mps_rank_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn fmt_scan(&mut self) -> *mut mps_fmt_scan_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn fmt_skip(&mut self) -> *mut mps_fmt_skip_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn fmt_fwd(&mut self) -> *mut mps_fmt_fwd_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn fmt_isfwd(&mut self) -> *mut mps_fmt_isfwd_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn fmt_pad(&mut self) -> *mut mps_fmt_pad_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn fmt_class(&mut self) -> *mut mps_fmt_class_t {
        unsafe { ::std::mem::transmute(self) }
    }
    pub fn pool(&mut self) -> *mut mps_pool_t {
        unsafe { ::std::mem::transmute(self) }
    }
}
pub type mps_arg_s = Struct_mps_arg_s;
pub type Enum_Unnamed3 = ::libc::c_uint;
pub const _mps_MESSAGE_TYPE_FINALIZATION: ::libc::c_uint = 0;
pub const _mps_MESSAGE_TYPE_GC: ::libc::c_uint = 1;
pub const _mps_MESSAGE_TYPE_GC_START: ::libc::c_uint = 2;
#[repr(C)]
pub struct Struct_mps_ap_s {
    pub init: mps_addr_t,
    pub alloc: mps_addr_t,
    pub limit: mps_addr_t,
    pub _frameptr: mps_addr_t,
    pub _enabled: mps_bool_t,
    pub _lwpoppending: mps_bool_t,
}
pub type mps_ap_s = Struct_mps_ap_s;
pub type mps_sac_t = *mut Struct__mps_sac_s;
#[repr(C)]
pub struct Struct__mps_sac_freelist_block_s {
    pub _size: size_t,
    pub _count: size_t,
    pub _count_max: size_t,
    pub _blocks: mps_addr_t,
}
pub type _mps_sac_freelist_block_s = Struct__mps_sac_freelist_block_s;
#[repr(C)]
pub struct Struct__mps_sac_s {
    pub _middle: size_t,
    pub _trapped: mps_bool_t,
    pub _freelists: [_mps_sac_freelist_block_s, ..16u],
}
pub type _mps_sac_s = Struct__mps_sac_s;
#[repr(C)]
pub struct Struct_mps_sac_class_s {
    pub mps_block_size: size_t,
    pub mps_cached_count: size_t,
    pub mps_frequency: ::libc::c_uint,
}
pub type mps_sac_class_s = Struct_mps_sac_class_s;
#[repr(C)]
pub struct Struct_mps_ld_s {
    pub _epoch: mps_word_t,
    pub _rs: mps_word_t,
}
pub type mps_ld_s = Struct_mps_ld_s;
#[repr(C)]
pub struct Struct_mps_ss_s {
    pub _zs: mps_word_t,
    pub _w: mps_word_t,
    pub _ufs: mps_word_t,
}
pub type mps_ss_s = Struct_mps_ss_s;
#[repr(C)]
pub struct Struct_mps_fmt_A_s {
    pub align: mps_align_t,
    pub scan: mps_fmt_scan_t,
    pub skip: mps_fmt_skip_t,
    pub copy: mps_fmt_copy_t,
    pub fwd: mps_fmt_fwd_t,
    pub isfwd: mps_fmt_isfwd_t,
    pub pad: mps_fmt_pad_t,
}
pub type mps_fmt_A_s = Struct_mps_fmt_A_s;
pub type mps_fmt_A_t = *mut Struct_mps_fmt_A_s;
#[repr(C)]
pub struct Struct_mps_fmt_B_s {
    pub align: mps_align_t,
    pub scan: mps_fmt_scan_t,
    pub skip: mps_fmt_skip_t,
    pub copy: mps_fmt_copy_t,
    pub fwd: mps_fmt_fwd_t,
    pub isfwd: mps_fmt_isfwd_t,
    pub pad: mps_fmt_pad_t,
    pub mps_class: mps_fmt_class_t,
}
pub type mps_fmt_B_s = Struct_mps_fmt_B_s;
pub type mps_fmt_B_t = *mut Struct_mps_fmt_B_s;
#[repr(C)]
pub struct Struct_mps_fmt_auto_header_s {
    pub align: mps_align_t,
    pub scan: mps_fmt_scan_t,
    pub skip: mps_fmt_skip_t,
    pub fwd: mps_fmt_fwd_t,
    pub isfwd: mps_fmt_isfwd_t,
    pub pad: mps_fmt_pad_t,
    pub mps_headerSize: size_t,
}
pub type mps_fmt_auto_header_s = Struct_mps_fmt_auto_header_s;
#[repr(C)]
pub struct Struct_mps_fmt_fixed_s {
    pub align: mps_align_t,
    pub scan: mps_fmt_scan_t,
    pub fwd: mps_fmt_fwd_t,
    pub isfwd: mps_fmt_isfwd_t,
    pub pad: mps_fmt_pad_t,
}
pub type mps_fmt_fixed_s = Struct_mps_fmt_fixed_s;
#[repr(C)]
pub struct Struct_mps_gen_param_s {
    pub mps_capacity: size_t,
    pub mps_mortality: ::libc::c_double,
}
pub type mps_gen_param_s = Struct_mps_gen_param_s;
pub type mps_tramp_t =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut ::libc::c_void, arg2: size_t)
                              -> *mut ::libc::c_void>;

pub type mps_formatted_objects_stepper_t =
    ::std::option::Option<extern "C" fn
                              (arg1: mps_addr_t, arg2: mps_fmt_t,
                               arg3: mps_pool_t, arg4: *mut ::libc::c_void,
                               arg5: size_t)>;

pub type mps_roots_stepper_t =
    ::std::option::Option<extern "C" fn
                              (arg1: *mut mps_addr_t, arg2: mps_root_t,
                               arg3: *mut ::libc::c_void, arg4: size_t)>;

// mpscamc.h
// typedef void (*mps_amc_apply_stepper_t)(mps_addr_t, void *, size_t);
pub type mps_amc_apply_stepper_t =
    ::std::option::Option<extern "C" fn
                              (arg1: mps_addr_t, 
                               arg2: *mut ::libc::c_void,
                               arg3: size_t)>;


#[repr(C)]
pub struct Struct_mps_pool_debug_option_s {
    pub fence_template: *const ::libc::c_void,
    pub fence_size: size_t,
    pub free_template: *const ::libc::c_void,
    pub free_size: size_t,
}
pub type mps_pool_debug_option_s = Struct_mps_pool_debug_option_s;

#[link(name = "mps", kind="static")]
extern "C" {
    pub static _mps_key_ARGS_END: Struct_mps_key_s;

    pub static mut mps_args_none: *mut mps_arg_s;

    pub static _mps_key_ARENA_SIZE: Struct_mps_key_s;

    pub static _mps_key_ARENA_GRAIN_SIZE: Struct_mps_key_s;
    pub static _mps_key_ARENA_ZONED: Struct_mps_key_s;
    pub static _mps_key_FORMAT: Struct_mps_key_s;
    pub static _mps_key_CHAIN: Struct_mps_key_s;
    pub static _mps_key_GEN: Struct_mps_key_s;
    pub static _mps_key_RANK: Struct_mps_key_s;
    pub static _mps_key_EXTEND_BY: Struct_mps_key_s;
    pub static _mps_key_LARGE_SIZE: Struct_mps_key_s;
    pub static _mps_key_MIN_SIZE: Struct_mps_key_s;
    pub static _mps_key_MEAN_SIZE: Struct_mps_key_s;
    pub static _mps_key_MAX_SIZE: Struct_mps_key_s;
    pub static _mps_key_ALIGN: Struct_mps_key_s;
    pub static _mps_key_SPARE: Struct_mps_key_s;
    pub static _mps_key_INTERIOR: Struct_mps_key_s;
    pub static _mps_key_VMW3_TOP_DOWN: Struct_mps_key_s;
    pub static _mps_key_FMT_ALIGN: Struct_mps_key_s;
    pub static _mps_key_FMT_HEADER_SIZE: Struct_mps_key_s;
    pub static _mps_key_FMT_SCAN: Struct_mps_key_s;
    pub static _mps_key_FMT_SKIP: Struct_mps_key_s;
    pub static _mps_key_FMT_FWD: Struct_mps_key_s;
    pub static _mps_key_FMT_ISFWD: Struct_mps_key_s;
    pub static _mps_key_FMT_PAD: Struct_mps_key_s;
    pub static _mps_key_FMT_CLASS: Struct_mps_key_s;
    pub static _mps_key_POOL_DEBUG_OPTIONS: Struct_mps_key_s;
    pub fn _mps_args_set_key(args: [mps_arg_s, ..32u], i: ::libc::c_uint,
                             key: mps_key_t);
    pub fn mps_rank_ambig() -> mps_rank_t;
    pub fn mps_rank_exact() -> mps_rank_t;
    pub fn mps_rank_weak() -> mps_rank_t;
    pub fn mps_arena_clamp(arg1: mps_arena_t);
    pub fn mps_arena_release(arg1: mps_arena_t);
    pub fn mps_arena_park(arg1: mps_arena_t);
    pub fn mps_arena_expose(arg1: mps_arena_t);
    pub fn mps_arena_unsafe_expose_remember_protection(arg1: mps_arena_t);
    pub fn mps_arena_unsafe_restore_protection(arg1: mps_arena_t);
    pub fn mps_arena_start_collect(arg1: mps_arena_t) -> mps_res_t;
    pub fn mps_arena_collect(arg1: mps_arena_t) -> mps_res_t;
    pub fn mps_arena_step(arg1: mps_arena_t, arg2: ::libc::c_double,
                          arg3: ::libc::c_double) -> mps_bool_t;
    pub fn mps_arena_create(arg1: *mut mps_arena_t,
                            arg2: mps_arena_class_t, ...) -> mps_res_t;

    /*pub fn mps_arena_create_v(arg1: *mut mps_arena_t, arg2: mps_arena_class_t,
                              arg3: va_list) -> mps_res_t;*/

    pub fn mps_arena_create_k(arg1: *mut mps_arena_t, arg2: mps_arena_class_t,
                              arg3: *mut mps_arg_s) -> mps_res_t;
    pub fn mps_arena_destroy(arg1: mps_arena_t);
    pub fn mps_arena_reserved(arg1: mps_arena_t) -> size_t;
    pub fn mps_arena_committed(arg1: mps_arena_t) -> size_t;
    pub fn mps_arena_spare_committed(arg1: mps_arena_t) -> size_t;
    pub fn mps_arena_commit_limit(arg1: mps_arena_t) -> size_t;
    pub fn mps_arena_commit_limit_set(arg1: mps_arena_t, arg2: size_t) ->
     mps_res_t;
    pub fn mps_arena_spare_commit_limit_set(arg1: mps_arena_t, arg2: size_t);
    pub fn mps_arena_spare_commit_limit(arg1: mps_arena_t) -> size_t;
    pub fn mps_arena_has_addr(arg1: mps_arena_t, arg2: mps_addr_t) ->
     mps_bool_t;
    pub fn mps_addr_pool(arg1: *mut mps_pool_t, arg2: mps_arena_t,
                         arg3: mps_addr_t) -> mps_bool_t;
    pub fn mps_addr_fmt(arg1: *mut mps_fmt_t, arg2: mps_arena_t,
                        arg3: mps_addr_t) -> mps_bool_t;
    pub fn mps_arena_extend(arg1: mps_arena_t, arg2: mps_addr_t, arg3: size_t)
     -> mps_res_t;
    pub fn mps_fmt_create_k(arg1: *mut mps_fmt_t, arg2: mps_arena_t,
                            arg3: *mut mps_arg_s) -> mps_res_t;
    pub fn mps_fmt_create_A(arg1: *mut mps_fmt_t, arg2: mps_arena_t,
                            arg3: *mut mps_fmt_A_s) -> mps_res_t;
    pub fn mps_fmt_create_B(arg1: *mut mps_fmt_t, arg2: mps_arena_t,
                            arg3: *mut mps_fmt_B_s) -> mps_res_t;
    pub fn mps_fmt_create_auto_header(arg1: *mut mps_fmt_t, arg2: mps_arena_t,
                                      arg3: *mut mps_fmt_auto_header_s) ->
     mps_res_t;
    pub fn mps_fmt_create_fixed(arg1: *mut mps_fmt_t, arg2: mps_arena_t,
                                arg3: *mut mps_fmt_fixed_s) -> mps_res_t;
    pub fn mps_fmt_destroy(arg1: mps_fmt_t);
    pub fn mps_pool_create(arg1: *mut mps_pool_t, arg2: mps_arena_t,
                           arg3: mps_pool_class_t, ...) -> mps_res_t;
    /*pub fn mps_pool_create_v(arg1: *mut mps_pool_t, arg2: mps_arena_t,
                             arg3: mps_pool_class_t, arg4: va_list) ->
     mps_res_t;*/
    pub fn mps_pool_create_k(arg1: *mut mps_pool_t, arg2: mps_arena_t,
                             arg3: mps_pool_class_t, arg4: *mut mps_arg_s) ->
     mps_res_t;
    pub fn mps_pool_destroy(arg1: mps_pool_t);
    pub fn mps_pool_total_size(arg1: mps_pool_t) -> size_t;
    pub fn mps_pool_free_size(arg1: mps_pool_t) -> size_t;
    pub fn mps_chain_create(arg1: *mut mps_chain_t, arg2: mps_arena_t,
                            arg3: size_t, arg4: *mut mps_gen_param_s) ->
     mps_res_t;
    pub fn mps_chain_destroy(arg1: mps_chain_t);
    pub fn mps_alloc(arg1: *mut mps_addr_t, arg2: mps_pool_t, arg3: size_t) ->
     mps_res_t;

    /*pub fn mps_alloc_v(arg1: *mut mps_addr_t, arg2: mps_pool_t, arg3: size_t,
                       arg4: va_list) -> mps_res_t;*/

    pub fn mps_free(arg1: mps_pool_t, arg2: mps_addr_t, arg3: size_t);
    pub fn mps_ap_create(arg1: *mut mps_ap_t, arg2: mps_pool_t, ...) ->
     mps_res_t;

    /*pub fn mps_ap_create_v(arg1: *mut mps_ap_t, arg2: mps_pool_t,
                           arg3: va_list) -> mps_res_t;*/

    pub fn mps_ap_create_k(arg1: *mut mps_ap_t, arg2: mps_pool_t,
                           arg3: *mut mps_arg_s) -> mps_res_t;
    pub fn mps_ap_destroy(arg1: mps_ap_t);
    pub fn mps_reserve(arg1: *mut mps_addr_t, arg2: mps_ap_t, arg3: size_t) ->
     mps_res_t;
    pub fn mps_commit(arg1: mps_ap_t, arg2: mps_addr_t, arg3: size_t) ->
     mps_bool_t;
    pub fn mps_ap_fill(arg1: *mut mps_addr_t, arg2: mps_ap_t, arg3: size_t) ->
     mps_res_t;
    pub fn mps_ap_fill_with_reservoir_permit(arg1: *mut mps_addr_t,
                                             arg2: mps_ap_t, arg3: size_t) ->
     mps_res_t;
    pub fn mps_ap_frame_push(arg1: *mut mps_frame_t, arg2: mps_ap_t) ->
     mps_res_t;
    pub fn mps_ap_frame_pop(arg1: mps_ap_t, arg2: mps_frame_t) -> mps_res_t;
    pub fn mps_ap_trip(arg1: mps_ap_t, arg2: mps_addr_t, arg3: size_t) ->
     mps_bool_t;
    pub fn mps_alloc_pattern_ramp() -> mps_alloc_pattern_t;
    pub fn mps_alloc_pattern_ramp_collect_all() -> mps_alloc_pattern_t;
    pub fn mps_ap_alloc_pattern_begin(arg1: mps_ap_t,
                                      arg2: mps_alloc_pattern_t) -> mps_res_t;
    pub fn mps_ap_alloc_pattern_end(arg1: mps_ap_t, arg2: mps_alloc_pattern_t)
     -> mps_res_t;
    pub fn mps_ap_alloc_pattern_reset(arg1: mps_ap_t) -> mps_res_t;
    pub fn mps_sac_create(arg1: *mut mps_sac_t, arg2: mps_pool_t,
                          arg3: size_t, arg4: *mut mps_sac_class_s) ->
     mps_res_t;
    pub fn mps_sac_destroy(arg1: mps_sac_t);
    pub fn mps_sac_alloc(arg1: *mut mps_addr_t, arg2: mps_sac_t, arg3: size_t,
                         arg4: mps_bool_t) -> mps_res_t;
    pub fn mps_sac_free(arg1: mps_sac_t, arg2: mps_addr_t, arg3: size_t);
    pub fn mps_sac_flush(arg1: mps_sac_t);
    pub fn mps_sac_fill(arg1: *mut mps_addr_t, arg2: mps_sac_t, arg3: size_t,
                        arg4: mps_bool_t) -> mps_res_t;
    pub fn mps_sac_empty(arg1: mps_sac_t, arg2: mps_addr_t, arg3: size_t);
    pub fn mps_reservoir_limit_set(arg1: mps_arena_t, arg2: size_t);
    pub fn mps_reservoir_limit(arg1: mps_arena_t) -> size_t;
    pub fn mps_reservoir_available(arg1: mps_arena_t) -> size_t;
    pub fn mps_reserve_with_reservoir_permit(arg1: *mut mps_addr_t,
                                             arg2: mps_ap_t, arg3: size_t) ->
     mps_res_t;
    pub fn mps_root_create(arg1: *mut mps_root_t, arg2: mps_arena_t,
                           arg3: mps_rank_t, arg4: mps_rm_t,
                           arg5: mps_root_scan_t, arg6: *mut ::libc::c_void,
                           arg7: size_t) -> mps_res_t;
    pub fn mps_root_create_table(arg1: *mut mps_root_t, arg2: mps_arena_t,
                                 arg3: mps_rank_t, arg4: mps_rm_t,
                                 arg5: *mut mps_addr_t, arg6: size_t) ->
     mps_res_t;
    pub fn mps_root_create_table_masked(arg1: *mut mps_root_t,
                                        arg2: mps_arena_t, arg3: mps_rank_t,
                                        arg4: mps_rm_t, arg5: *mut mps_addr_t,
                                        arg6: size_t, arg7: mps_word_t) ->
     mps_res_t;
    pub fn mps_root_create_fmt(arg1: *mut mps_root_t, arg2: mps_arena_t,
                               arg3: mps_rank_t, arg4: mps_rm_t,
                               arg5: mps_fmt_scan_t, arg6: mps_addr_t,
                               arg7: mps_addr_t) -> mps_res_t;
    pub fn mps_root_create_reg(arg1: *mut mps_root_t, arg2: mps_arena_t,
                               arg3: mps_rank_t, arg4: mps_rm_t,
                               arg5: mps_thr_t, arg6: mps_reg_scan_t,
                               arg7: *mut ::libc::c_void, arg8: size_t) ->
     mps_res_t;
    pub fn mps_root_destroy(arg1: mps_root_t);
    pub fn mps_stack_scan_ambig(arg1: mps_ss_t, arg2: mps_thr_t,
                                arg3: *mut ::libc::c_void, arg4: size_t) ->
     mps_res_t;
    pub fn mps_tramp(arg1: *mut *mut ::libc::c_void, arg2: mps_tramp_t,
                     arg3: *mut ::libc::c_void, arg4: size_t);
    pub fn mps_thread_reg(arg1: *mut mps_thr_t, arg2: mps_arena_t) ->
     mps_res_t;
    pub fn mps_thread_dereg(arg1: mps_thr_t);
    pub fn mps_ld_reset(arg1: mps_ld_t, arg2: mps_arena_t);
    pub fn mps_ld_add(arg1: mps_ld_t, arg2: mps_arena_t, arg3: mps_addr_t);
    pub fn mps_ld_merge(arg1: mps_ld_t, arg2: mps_arena_t, arg3: mps_ld_t);
    pub fn mps_ld_isstale(arg1: mps_ld_t, arg2: mps_arena_t, arg3: mps_addr_t)
     -> mps_bool_t;
    pub fn mps_ld_isstale_any(arg1: mps_ld_t, arg2: mps_arena_t) ->
     mps_bool_t;
    pub fn mps_collections(arg1: mps_arena_t) -> mps_word_t;
    pub fn mps_message_type_enable(arg1: mps_arena_t,
                                   arg2: mps_message_type_t);
    pub fn mps_message_type_disable(arg1: mps_arena_t,
                                    arg2: mps_message_type_t);
    pub fn mps_message_poll(arg1: mps_arena_t) -> mps_bool_t;
    pub fn mps_message_queue_type(arg1: *mut mps_message_type_t,
                                  arg2: mps_arena_t) -> mps_bool_t;
    pub fn mps_message_get(arg1: *mut mps_message_t, arg2: mps_arena_t,
                           arg3: mps_message_type_t) -> mps_bool_t;
    pub fn mps_message_discard(arg1: mps_arena_t, arg2: mps_message_t);
    pub fn mps_message_type(arg1: mps_arena_t, arg2: mps_message_t) ->
     mps_message_type_t;
    pub fn mps_message_clock(arg1: mps_arena_t, arg2: mps_message_t) ->
     mps_clock_t;
    pub fn mps_message_finalization_ref(arg1: *mut mps_addr_t,
                                        arg2: mps_arena_t,
                                        arg3: mps_message_t);
    pub fn mps_message_gc_live_size(arg1: mps_arena_t, arg2: mps_message_t) -> size_t;
    pub fn mps_message_gc_condemned_size(arg1: mps_arena_t,
                                         arg2: mps_message_t) -> size_t;
    pub fn mps_message_gc_not_condemned_size(arg1: mps_arena_t,
                                             arg2: mps_message_t) -> size_t;
    pub fn mps_message_gc_start_why(arg1: mps_arena_t, arg2: mps_message_t) -> *const ::libc::c_char;
    pub fn mps_finalize(arg1: mps_arena_t, arg2: *mut mps_addr_t) -> mps_res_t;
    pub fn mps_definalize(arg1: mps_arena_t, arg2: *mut mps_addr_t) -> mps_res_t;
    pub fn mps_telemetry_control(arg1: mps_word_t, arg2: mps_word_t) -> mps_word_t;
    pub fn mps_telemetry_set(arg1: mps_word_t);
    pub fn mps_telemetry_reset(arg1: mps_word_t);
    pub fn mps_telemetry_get() -> mps_word_t;
    pub fn mps_telemetry_intern(arg1: *const ::libc::c_char) -> mps_label_t;
    pub fn mps_telemetry_label(arg1: mps_addr_t, arg2: mps_label_t);
    pub fn mps_telemetry_flush();
    pub fn mps_arena_formatted_objects_walk(arg1: mps_arena_t,
                                            arg2:
                                                mps_formatted_objects_stepper_t,
                                            arg3: *mut ::libc::c_void,
                                            arg4: size_t);
    pub fn mps_arena_roots_walk(arg1: mps_arena_t, arg2: mps_roots_stepper_t,
                                arg3: *mut ::libc::c_void, arg4: size_t);
    pub fn mps_pool_check_fenceposts(arg1: mps_pool_t);
    pub fn mps_pool_check_free_space(arg1: mps_pool_t);
    pub fn mps_fix(arg1: mps_ss_t, arg2: *mut mps_addr_t) -> mps_res_t;
    pub fn _mps_fix2(arg1: mps_ss_t, arg2: *mut mps_addr_t) -> mps_res_t;


    //#include "mpsavm.h"
    pub fn mps_arena_class_vm() -> mps_arena_class_t;

    //#include "mpsacl.h"
    pub fn mps_arena_class_cl() -> mps_arena_class_t;


    //#include "mpscmvff.h"
    //#define mps_mvff_free_size         mps_pool_free_size
    //#define mps_mvff_size              mps_pool_total_size
    pub fn mps_class_mvff() -> mps_pool_class_t;
    pub fn mps_class_mvff_debug() -> mps_pool_class_t;

    pub static _mps_key_MVFF_SLOT_HIGH : Struct_mps_key_s;
    pub static _mps_key_MVFF_ARENA_HIGH : Struct_mps_key_s;
    pub static _mps_key_MVFF_FIRST_FIT : Struct_mps_key_s;

    // mpscamc.h
    pub fn mps_class_amc()  -> mps_pool_class_t;
    pub fn mps_class_amcz() -> mps_pool_class_t;

    pub fn mps_amc_apply(arg1 : mps_pool_t, arg2 : mps_amc_apply_stepper_t, arg3 :  *mut ::libc::c_void, arg4 : size_t) -> ::libc::c_void;

}

// mps.h
static MPS_KEY_ARGS_END : mps_key_t  = (&_mps_key_ARGS_END);
static MPS_KEY_ARENA_SIZE : mps_key_t = (&_mps_key_ARENA_SIZE);
static MPS_KEY_ARENA_GRAIN_SIZE : mps_key_t = (&_mps_key_ARENA_GRAIN_SIZE);
static MPS_KEY_ARENA_ZONED : mps_key_t = (&_mps_key_ARENA_ZONED);
static MPS_KEY_FORMAT : mps_key_t = (&_mps_key_FORMAT);
static MPS_KEY_CHAIN : mps_key_t = (&_mps_key_CHAIN);
static MPS_KEY_GEN : mps_key_t = (&_mps_key_GEN);
static MPS_KEY_RANK : mps_key_t = (&_mps_key_RANK);
static MPS_KEY_EXTEND_BY : mps_key_t = (&_mps_key_EXTEND_BY);
static MPS_KEY_LARGE_SIZE : mps_key_t = (&_mps_key_LARGE_SIZE);
static MPS_KEY_MIN_SIZE : mps_key_t = (&_mps_key_MIN_SIZE);
static MPS_KEY_MEAN_SIZE : mps_key_t = (&_mps_key_MEAN_SIZE);
static MPS_KEY_MAX_SIZE : mps_key_t = (&_mps_key_MAX_SIZE);
static MPS_KEY_ALIGN : mps_key_t = (&_mps_key_ALIGN);
static MPS_KEY_SPARE : mps_key_t = (&_mps_key_SPARE);
static MPS_KEY_INTERIOR : mps_key_t = (&_mps_key_INTERIOR);
static MPS_KEY_VMW3_TOP_DOWN : mps_key_t = (&_mps_key_VMW3_TOP_DOWN);
static MPS_KEY_FMT_ALIGN : mps_key_t = (&_mps_key_FMT_ALIGN);
static MPS_KEY_FMT_HEADER_SIZE : mps_key_t = (&_mps_key_FMT_HEADER_SIZE);
static MPS_KEY_FMT_SCAN : mps_key_t = (&_mps_key_FMT_SCAN);
static MPS_KEY_FMT_SKIP : mps_key_t = (&_mps_key_FMT_SKIP);
static MPS_KEY_FMT_FWD : mps_key_t = (&_mps_key_FMT_FWD);
static MPS_KEY_FMT_ISFWD : mps_key_t = (&_mps_key_FMT_ISFWD);
static MPS_KEY_FMT_PAD : mps_key_t = (&_mps_key_FMT_PAD);
static MPS_KEY_FMT_CLASS : mps_key_t = (&_mps_key_FMT_CLASS);

//mpscmvff.h
static MPS_KEY_MVFF_SLOT_HIGH : mps_key_t = (&_mps_key_MVFF_SLOT_HIGH);
static MPS_KEY_MVFF_ARENA_HIGH : mps_key_t = (&_mps_key_MVFF_ARENA_HIGH);
static MPS_KEY_MVFF_FIRST_FIT : mps_key_t = (&_mps_key_MVFF_FIRST_FIT);

fn main() {
    
    let mut res : mps_res_t = unsafe{ mem::zeroed() };

    let mut arena : mps_arena_t = unsafe{ mem::zeroed() };
    let mut pool : mps_pool_t = unsafe{ mem::zeroed() };
    let mut alloc_point : mps_ap_t = unsafe{ mem::zeroed() };


    // ------------------------ Arena ------------------------
    let mut arena_args : [mps_arg_s, ..2] = unsafe{  mem::zeroed() };

    arena_args[0] = Struct_mps_arg_s { key: MPS_KEY_ARENA_SIZE,
                                 val:  mps_args_val { data: [32 * 1024 * 1024] }
                               };
    arena_args[1] = Struct_mps_arg_s { key: MPS_KEY_ARGS_END,
                                 val:  mps_args_val { data: [0] }
                               };
    
    res = unsafe { mps_arena_create_k(&mut arena, mps_arena_class_vm(), arena_args.as_mut_ptr() ) };
    if (MPS_RES_OK != res) {
        println!("Clould not creat arena");
    } else {
        println!("Arena created");
    }
    

    // ------------------------ Pool ------------------------
    const mvff_args_size : uint = 1;
    let mut mvff_args : [mps_arg_s, ..mvff_args_size] = unsafe{ mem::zeroed() };
    
    

    mvff_args[mvff_args_size-1] = Struct_mps_arg_s { key: MPS_KEY_ARGS_END,
                                 val:  mps_args_val { data: [0] }
                               };
    

    res = unsafe { mps_pool_create_k(&mut pool, arena, mps_class_mvff(), mvff_args.as_mut_ptr()) };
    if (MPS_RES_OK != res) {
        println!("Clould not creat pool");
    } else {
        println!("Pool created");
    }
    
    // ------------------------ Allocation point ------------------------
    
    const ap_args_size : uint = 1;
    let mut ap_args : [mps_arg_s, ..ap_args_size] = unsafe{  mem::zeroed() };
    
    ap_args[ap_args_size-1] = Struct_mps_arg_s { key: MPS_KEY_ARGS_END,
                                                 val:  mps_args_val { data: [0] }
                                                };

    res =  unsafe { mps_ap_create_k(&mut alloc_point, pool, ap_args.as_mut_ptr()) };
    if (MPS_RES_OK != res) {
        println!("Clould not creat AP");
    } else {
        println!("AP created");
    }

    // ------------------------ Allocation ----------------------

    let mut addr : mps_addr_t = unsafe{ mem::zeroed() };

    loop {
        res = unsafe { mps_reserve(&mut addr, alloc_point, 32) };
        if (MPS_RES_OK != res) {
            println!("Clould not reserve");
        } else {
            println!("Reserved!");
        }



        if unsafe { mps_commit(alloc_point, addr, 32) } == 1 {
            println!("allocated: {}", addr);
            break;
        } else {
            println!("not jet allocated"); 
        }
    }

    // ------------------
    /*
    MPS_ARGS_BEGIN(args) {
        MPS_ARGS_ADD(args, MPS_KEY_FMT_ALIGN, ALIGNMENT);
        MPS_ARGS_ADD(args, MPS_KEY_FMT_SCAN, obj_scan);
        MPS_ARGS_ADD(args, MPS_KEY_FMT_SKIP, obj_skip);
        MPS_ARGS_ADD(args, MPS_KEY_FMT_FWD, obj_fwd);
        MPS_ARGS_ADD(args, MPS_KEY_FMT_ISFWD, obj_isfwd);
        MPS_ARGS_ADD(args, MPS_KEY_FMT_PAD, obj_pad);
        res = mps_fmt_create_k(&obj_fmt, arena, args);
    } MPS_ARGS_END(args);
    if (res != MPS_RES_OK) error("Couldn't create obj format");
    */

    const fmt_args_size : uint = 6;

    let mut obj_fmt : mps_fmt_t = unsafe { mem::zeroed() };

    let mut fmt_args : [mps_arg_s, ..fmt_args_size] = unsafe{ mem::zeroed() };

    

    fmt_args[0] = Struct_mps_arg_s { key: MPS_KEY_FMT_ALIGN,
                                     val: mps_args_val { data: [ 0 ] }
                                   };

    fmt_args[1] = Struct_mps_arg_s { key: MPS_KEY_FMT_SCAN,
                                     val: mps_args_val { data: [ 0 ] }
                                   };

    fmt_args[2] = Struct_mps_arg_s { key: MPS_KEY_FMT_SKIP,
                                     val: mps_args_val { data: [ 0 ] }
                                   };

    fmt_args[3] = Struct_mps_arg_s { key: MPS_KEY_FMT_FWD,
                                     val: mps_args_val { data: [ 0 ] }
                                   };

    fmt_args[4] = Struct_mps_arg_s { key: MPS_KEY_FMT_ISFWD,
                                     val: mps_args_val { data: [ 0 ] }
                                   };

    fmt_args[5] = Struct_mps_arg_s { key: MPS_KEY_FMT_PAD,
                                     val: mps_args_val { data: [ 0 ] }
                                   };

    res = unsafe { mps_fmt_create_k(&mut obj_fmt, arena, fmt_args.as_mut_ptr()) };


    if (MPS_RES_OK != res) {
        println!("Couldn't object format created");
    } else {
        println!("object format created");
    }

      unsafe { std::mem::size_of(::libc::c_ulong) } 
    

}
        //let mut args : &[Struct_mps_arg_s] = &[ Struct_mps_arg_s { key: mem::uninitialized() ,
        //                                                           val: [0] as mps_args_val  } ];
        //let mut args : &[Struct_mps_arg_s] = [ mem::uninitialized(), ..32 ];

       
        // = mem::uninitialized();

        //let mut args : [Struct_mps_arg_s, ..32];
        //let mut args : &[mps_arg_s, ..32];  

     
        //Vec::from_fn(32, |_| Nil)
        //_mps_args_set_key(args, 0 as u32, &_mps_key_ARGS_END);  //MPS_KEY_ARGS_END );



